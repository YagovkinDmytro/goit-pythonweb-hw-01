# SOLID-принципи в бібліотечній системі

## 1. Принцип єдиної відповідальності (SRP)

**Суть:**
Клас повинен мати лише одну причину для зміни. Тобто, кожен клас відповідає за одну зону відповідальності.

Клас відповідає лише за зберігання інформації про книгу (_title, author, year_).  
Він не містить логіки бібліотеки або управління книгами.

class Book:
def **init**(self, title, author, year):
self.title = title
self.author = author
self.year = year
Висновок: Це ідеально відповідає SRP: один клас — одна відповідальність.

## 2. Принцип відкритості/закритості (OCP)

**Суть:**
Клас має бути відкритим для розширення, але закритим для модифікації.

Library: Інтерфейс LibraryInterface, і клас Library його реалізує. Це дозволяє розширювати функціональність через створення нових класів (наприклад, DigitalLibrary, ExtendedLibrary), не змінюючи існуючий код Library.

Наприклад, можна створити новий клас:
class ExtendedLibrary(Library):
def find_by_author(self, author):
return [book for book in self.books if book.author == author]
Без зміни коду оригінальної Library!
Висновок: OCP дотримано — код вже дозволяє розширюватися через наслідування/реалізацію інтерфейсу.

## 3. Принцип підстанови Лісков (LSP)

**Суть:**
Будь-який підклас/реалізація повинна замінювати базовий клас без порушень роботи програми.

Створив LibraryInterface і реалізував його в Library. У твоєму коді менеджер працює з LibraryInterface (через LibraryManager(library)).
manager = LibraryManager(library)
Якщо ми підставимо замість Library інший клас, що реалізує LibraryInterface, код продовжить працювати без змін.

Наприклад:
alt_library = ExtendedLibrary()
manager = LibraryManager(alt_library)
Висновок: LSP виконано: підкласи можуть замінювати Library без помилок.

## 4. Принцип розділення інтерфейсів (ISP)

**Суть:**
Клієнти не повинні залежати від методів, які вони не використовують. Інтерфейси мають бути вузькими і специфічними.

LibraryInterface, що визначає рівно ті методи, які треба для роботи з бібліотекою:
class LibraryInterface(ABC):
@abstractmethod
def add_book(self, title, author, year):
pass

    @abstractmethod
    def remove_book(self, title):
        pass

    @abstractmethod
    def show_books(self):
        pass

Інтерфейс вузький і чіткий — нема зайвих методів (наприклад, нема методів пошуку, якщо вони не потрібні).
Висновок: ISP виконано: інтерфейс чіткий і не нав'язує зайвих методів.

## 5. Принцип інверсії залежностей (DIP)

**Суть:**
Класи вищого рівня повинні залежати від абстракцій, а не від конкретних реалізацій.

LibraryManager отримує на вхід інтерфейс LibraryInterface:
class LibraryManager:
def **init**(self, library: LibraryInterface):
self.library = library
Додати типізацію для повної відповідності, напр.: library: LibraryInterface
Це означає, що він залежить не від конкретного класу Library, а від абстракції (LibraryInterface).
У коді:
library = Library()
manager = LibraryManager(library)
Головне: ми можемо підставити будь-який об'єкт, що реалізує LibraryInterface — і менеджер не залежить від деталей реалізації.
Висновок: DIP виконано: менеджер залежить від абстракції, а не конкретної реалізації.

ПІДСУМОК:

SRP - Book відповідає лише за зберігання даних.

OCP - Можна додати нову бібліотеку через новий клас без зміни Library.

LSP - Підкласи легко замінюють Library.

ISP - Інтерфейс чіткий, містить тільки потрібні методи.

DIP - LibraryManager залежить від абстракції, не від конкретної реалізації.

Цей проект повністю відповідає SOLID-принципам, що гарантує гнучкість, масштабованість та простоту підтримки!
